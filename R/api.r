#' GDAX
#'
#' Make request to GDAX
#'
#' @param method appropriate web method. These map to httr::GET, httr::POST, etc...
#' @param ... extra arguments passed to httr::GET, httr::POST, etc...
#' @keywords internal
#' @examples
#' \dontrun{
#' gdax_get("accounts", query = list(date = "2017-01-01"))
#' }
gdax_api <- function(endpoint, method = c("get", "post", "put", "delete"), ...) {
  stopifnot(length(endpoint) == 1L)

  baseurl <- "https://api.gdax.com"
  path <- paste("", gsub("^/", "", endpoint), sep = "/")
  url <- httr::modify_url(baseurl, path = path)

  # get api key and passphrase
  api_key <- Sys.getenv("GDAX_KEY")
  api_passphrase <- Sys.getenv("GDAX_PASSPHRASE")

  # extract and validate arguments
  method <- match.arg(method)
  extra <- list(...)
  request_body <- get0("body", list2env(extra), inherits = FALSE, ifnotfound = "")

  # generate signature and timestamp
  timestamp <- as.character(as.integer(Sys.time()))
  signature <- access_signature(timestamp, path, request_body, method = method)

  # build headers
  # Please supply API version (YYYY-MM-DD) as CB-VERSION header
  headers <- httr::add_headers(
    "CB-ACCESS-KEY" = api_key,
    "CB-ACCESS-SIGN" = signature,
    "CB-ACCESS-TIMESTAMP" = timestamp,
    "CB-ACCESS-PASSPHRASE" = api_passphrase,
    "CB-VERSION" = "2018-01-22",
    "Content-Type" = "application/json",
    "Accept" = "application/json",
    "User-Agent" = "github.com/zamorarr/gdaxr")

  # get response
  method_fun <- switch(
    method,
    "get" = httr::GET,
    "post" = httr::POST,
    "put" = httr::PUT,
    "delete" = httr::DELETE
  )
  response <- method_fun(url, headers, ...)

  # check response type
  if (httr::http_type(response) != "application/json") {
    stop("API did not return json", call. = FALSE)
  }

  # parse content
  content <- httr::content(response, "text")
  json <- jsonlite::fromJSON(content, simplifyVector = FALSE)

  # check errors
  if (httr::http_error(response)) {
    stop(
      sprintf(
        "gdax API request failed [%s]\n%s\n",
        httr::status_code(response),
        json$errors[[1]]$message
        ),
      call. = FALSE
    )
  }

  # return object
  structure(json, class = "gdax_api", path = path, response = response)
}

#' @rdname gdax_api
#' @export
gdax_get <- function(endpoint, ...) gdax_api(endpoint, "get", ...)

#' @rdname gdax_api
#' @export
gdax_post <- function(endpoint, ...) gdax_api(endpoint, "post", ..., encode = "json")

#' @rdname gdax_api
#' @export
gdax_put <- function(endpoint, ...) gdax_api(endpoint, "put", ..., encode = "json")

#' @rdname gdax_api
#' @export
gdax_delete <- function(endpoint, ...) gdax_api(endpoint, "delete", ..., encode = "json")

#' @export
print.gdax_api <- function(x, ...) {
  cat("<gdax ", attr(x, "path"), ">\n", sep = "")
  utils::str(x, 1, give.attr = FALSE)
  invisible(x)
}

#' Generate an api access signature
#'
#' The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the
#' secret key on the prehash string timestamp + method + requestPath + body
#' (where + represents string concatenation). The timestamp value is the same as
#'  the CB-ACCESS-TIMESTAMP header.
#'
#'
#' @param timestamp The CB-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch.
#' @param request_path path requesting
#' @param request_body The body is the request body string or omitted if there is no request body (typically for GET requests).
#' @param method The method should be UPPER CASE.
#'
#' @keywords internal
access_signature <- function(timestamp, request_path, request_body = "",
                             method = c("get", "post", "put", "delete") ) {
  method <- toupper(match.arg(method))

  if (any(nchar(request_body) > 0)) {
    body <- paste(jsonlite::toJSON(request_body, auto_unbox = TRUE), collapse = "\n")
  } else {
    body <- ""
  }

  # message
  msg <- paste0(timestamp, method, request_path, body)

  # Remember to first base64-decode the alphanumeric secret string (resulting in 64 bytes)
  # before using it as the key for HMAC.
  api_secret <- base64enc::base64decode(Sys.getenv("GDAX_SECRET"))
  raw_hmac <- digest::hmac(api_secret, msg, "sha256", raw = TRUE)

  # Also, base64-encode the digest output before sending in the header.
  base64enc::base64encode(raw_hmac)
}
